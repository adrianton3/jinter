// Generated by CoffeeScript 1.8.0
(function() {
  var snippets;

  snippets = {
    'literal': {
      'numbers': '1',
      'booleans': 'true',
      'strings': '"asd"'
    },
    'binary +': {
      'numbers': '2 + 3',
      'strings': '"asd" + "dsa"',
      'number and string': '123 + "asd"',
      'string and number': '"asd" + 123',
      'with toString': 'var a = { toString: function () { return "asd" } };\na + 123',
      'with valueOf': 'var a = { valueOf: function () { return 234 } };\na + 123',
      'valueOf has precedence over toString': 'var a = {\n	toString: function () { return "asd" },\n	valueOf: function () { return 234 }\n};\na + 123',
      'toString can return a number': 'var a = { toString: function () { return 234 } };\na + 123',
      'valueOf can return a string': 'var a = { valueOf: function () { return "asd" } };\na + 123'
    },
    'unary +': {
      'number': '+123',
      'numberic string': '+"123"',
      'non-numberic string': '+"asd"',
      'boolean': '+true',
      'null': '+null',
      'undefined': '+undefined',
      'object': '+({})'
    },
    'unary -': {
      'number': '-123',
      'numberic string': '-"123"',
      'non-numberic string': '-"asd"',
      'boolean': '-true',
      'null': '-null',
      'undefined': '-undefined',
      'object': '-({})'
    },
    '! operator': {
      'number': '!123',
      'string': '!"asd"',
      'boolean': '!true',
      'null': '!null',
      'undefined': '!undefined',
      'object': '!({})'
    },
    'binary -': {
      'numbers': '2 - 3',
      'strings': '"2" - "3"',
      'number and string': '123 + "234"',
      'string and number': '"234" + 123'
    },
    '* operator': {
      'numbers': '2 * 3',
      'strings': '"2" * "3"'
    },
    '&& operator': {
      'numbers': '2 && 3',
      'strings': '"asd" && ""',
      'booleans': 'false && true',
      'null': 'true && null',
      'undefined': 'true && undefined'
    },
    '|| operator': {
      'numbers': '2 || 3',
      'strings': '"asd" || ""',
      'booleans': 'false || true',
      'null': 'true || null',
      'undefined': 'true || undefined'
    },
    '=== operator': {
      'numbers': '1 + 4 === 2 + 3',
      'strings': '"a" + "sd" === "as" + "d"',
      'boolean': 'false === true',
      'different objects': '({}) === ({})',
      'same object': 'var a = {};\na === a',
      'null': 'null === null',
      'undefined': 'undefined === undefined'
    },
    'if expressions': {
      'booleans cast to boolean': 'true ? 123 : 321',
      'numbers cast to boolean': '123 ? 456 : 789',
      'strings cast to boolean': '"" ? 456 : 789'
    },
    'function calls': {
      'one parameter': '(function () { return 123; })()',
      'two parameters': '(function (a) { return a; })(123)',
      'three parameters': '(function (a, b) { return a + b; })(123, 456)'
    },
    'objects': {
      'can lookup a member': '({ a: 123 }).a',
      'can call a member': '({\n	a: 123,\n	b: function () { return this.a }\n}).b()',
      'computed member expression': '({ asd: 123 })["a" + "sd"]',
      'can call a computed member': '({\n	asd: function () { return 123 }\n})["a" + "sd"]()',
      'can define a getter': '({\n	get a() { return 123 }\n}).a',
      'can define a setter': 'var s;\nvar a = {\n	get a() { return s },\n	set a(value) { s = value * 2 }\n};\na.a = 123;\na.a'
    },
    'assignment expressions': {
      'one assignment': 'var a;\na = 123;\na',
      'two assignments': 'var a, b;\na = 123;\nb = 456;\na + b',
      'assignment is an expression': 'var a, b;\na = b = 123;\na + b',
      'assignment to object member': 'var a;\na = {};\na.b = 123;\na.b',
      'assignment to computed object member': 'var a;\na = {};\na["a" + "sd"] = 123;\na.asd',
      'assignment from declaration': 'var a = 123, b = 456;\na + b',
      'assignment from var': 'var a = 123, b = a;\na + b'
    },
    '__proto__ and the prototype chain': {
      'lookup reached proto': 'var a = {};\na.__proto__ = { b: 123 };\na.b',
      'lookup does not reach proto': 'var a = { b: 456 };\na.__proto__ = { b: 123 };\na.b',
      'prototype chain': 'var a = {\n	__proto__: {\n		__proto__: {\n			b: 123\n		}\n	}\n};\na.b',
      'lookup on __proto__ directly': 'var a = {\n	__proto__: {\n		b: 123\n	}\n};\na.__proto__.b'
    },
    'if statements': {
      'simple if statement': 'var a;\nif (true) {\n	a = 123;\n} else {\n	a = 321;\n}\na',
      'return from if statement': '(function () {\n	if (true) {\n		return 123;\n	} else {\n		return 321;\n	}\n})()'
    },
    'new': {
      'instantiation and assignment to this': 'var A = function () { this.b = 123; };\nvar a = new A;\na.b',
      'set prototype': 'var A = function () { this.b = 123; };\nA.prototype = { c: 456 };\nvar a = new A;\na.b + a.c',
      'inheritance': 'var A = function () {};\nA.prototype = { c: 456 };\nvar B = function () {};\nB.prototype = new A;\nvar b = new B;\nb.c'
    },
    'function declarations': {
      'functions are bound to their name': 'function f() { return 123 }\nf()',
      'all functions are bound to their name before execution': 'function f() { return g() }\nfunction g() { return 123 }\nf()'
    },
    'function calls': {
      'more parameters than formal arguments': '(function (a, b) { return 123 })(1, 2, 3, 4)',
      'functions return undefined by default': '(function () {})()',
      'currying': '(function (a) {\n	return function (b) {\n		return a + b\n	}\n})(123)(456)'
    },
    'while': {
      'simple loop': 'var i = 10, sum = 0;\nwhile (i) {\n	sum = sum + i;\n	i = i - 1;\n}\nsum',
      'return from while': 'function f() {\n	while (true) {\n		return 123\n	}\n}\nf()',
      'return from nested while': 'function f() {\n	while (true) {\n		while (true) {\n			return 123\n		}\n	}\n}\nf()'
    },
    'for': {
      'simple for': 'var sum = 0;\nfor (var i = 10; i; i = i - 1) {\n	sum = sum + i;\n}\nsum',
      'return from for': 'function f() {\n	var sum = 0;\n	for (var i = 10; i; i = i - 1) {\n		return 123\n	}\n}\nf()'
    },
    'recursion': {
      'function declaration can refer to itself': 'function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n}\nsum(10)',
      'named function expression can refer to itself': '(function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n})(10)'
    },
    'scopes': {
      'undefined is located on window': 'undefined',
      'window is located on window': 'window === window.window',
      'local variables shadow top level variables': 'var a = 123;\n(function () {\n	var a = 321;\n	return a;\n})()',
      'local variables shadow parent scopes': '(function () {\n	var a = 123;\n	return (function () {\n		var a = 321;\n		return a;\n	})()\n})()',
      'local variables does not shadow function parameter': '(function (a) {\n	var a;\n	return a;\n})(123)'
    },
    'Object.create': {
      'can create an object with a prototype': 'var a = Object.create({ b: 123 });\na.b',
      'can access prototype via __proto__': 'var a = Object.create({ b: 123 });\na.__proto__.b'
    },
    'Object.keys': {
      'returns an empty array for an empty object': 'Object.keys({})',
      'returns the keys of an object': 'Object.keys({ a: 123, b: 321 })'
    },
    'Array': {
      'can construct': 'var a = [11, 22, 33];\na[1]',
      'can set/get numeric property': 'var a = [];\na[3] = 123;\na[3]'
    },
    'Array length': {
      'for empty arrays': '[].length',
      'for non-empty arrays': '[11, 22, 33].length',
      'for sparse arrays': 'var a = [];\na[3] = 123;\na.length'
    },
    'Array methods': {
      'toString': '[11, 22, 33, 44, 55].toString()',
      'slice': '[11, 22, 33, 44, 55].slice(2, 3)',
      'push return': '[11, 22, 33, 44, 55].push(66)',
      'push original array': 'var a = [11, 22, 33, 44, 55];\na.push(66);\na',
      'pop return': '[11, 22, 33, 44, 55].pop()',
      'pop original array': 'var a = [11, 22, 33, 44, 55];\na.pop();\na'
    },
    'Function methods': {
      'apply': 'var f = function (a, b) { return a + b };\nf.apply(null, [11, 22])',
      'apply with this': 'var f = function (a) { return this + a };\nf.apply(11, [22])',
      'call': 'var f = function (a, b) { return a + b };\nf.call(null, 11, 22)',
      'call with this': 'var f = function (a) { return this + a };\nf.call(11, 22)'
    }
  };

  if (window.snippets == null) {
    window.snippets = {};
  }

  Object.assign(window.snippets, snippets);

}).call(this);
