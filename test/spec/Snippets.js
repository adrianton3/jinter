// Generated by CoffeeScript 1.8.0
(function() {
  var snippets;

  snippets = {
    'literal': {
      'numbers': '1',
      'booleans': 'true',
      'strings': '"asd"'
    },
    'binary +': {
      'numbers': '2 + 3',
      'strings': '"asd" + "dsa"',
      'number and string': '123 + "asd"',
      'string and number': '"asd" + 123',
      'with toString': 'var a = { toString: function () { return "asd" } };\na + 123',
      'with valueOf': 'var a = { valueOf: function () { return 234 } };\na + 123',
      'valueOf has precedence over toString': 'var a = {\n	toString: function () { return "asd" },\n	valueOf: function () { return 234 }\n};\na + 123',
      'toString can return a number': 'var a = { toString: function () { return 234 } };\na + 123',
      'valueOf can return a string': 'var a = { valueOf: function () { return "asd" } };\na + 123'
    },
    'unary +': {
      'number': '+123',
      'numberic string': '+"123"',
      'non-numberic string': '+"asd"',
      'boolean': '+true',
      'null': '+null',
      'undefined': '+undefined',
      'object': '+({})'
    },
    'unary -': {
      'number': '-123',
      'numberic string': '-"123"',
      'non-numberic string': '-"asd"',
      'boolean': '-true',
      'null': '-null',
      'undefined': '-undefined',
      'object': '-({})'
    },
    '! operator': {
      'number': '!123',
      'string': '!"asd"',
      'boolean': '!true',
      'null': '!null',
      'undefined': '!undefined',
      'object': '!({})'
    },
    'binary -': {
      'numbers': '2 - 3',
      'strings': '"2" - "3"',
      'number and string': '123 + "234"',
      'string and number': '"234" + 123'
    },
    '* operator': {
      'numbers': '2 * 3',
      'strings': '"2" * "3"'
    },
    '&& operator': {
      'numbers': '2 && 3',
      'strings': '"asd" && ""',
      'booleans': 'false && true',
      'null': 'true && null',
      'undefined': 'true && undefined'
    },
    '|| operator': {
      'numbers': '2 || 3',
      'strings': '"asd" || ""',
      'booleans': 'false || true',
      'null': 'true || null',
      'undefined': 'true || undefined'
    },
    '=== operator': {
      'numbers': '1 + 4 === 2 + 3',
      'strings': '"a" + "sd" === "as" + "d"',
      'boolean': 'false === true',
      'different objects': '({}) === ({})',
      'same object': 'var a = {};\na === a',
      'null': 'null === null',
      'undefined': 'undefined === undefined'
    },
    '!== operator': {
      'numbers': '2 + 4 !== 2 + 3',
      'strings': '"as" !== "as" + "d"',
      'boolean': 'true !== true',
      'different objects': '({}) !== ({})',
      'same object': 'var a = {};\na !== a',
      'null': 'null !== null',
      'undefined': 'undefined !== undefined',
      'null and undefined': 'null !== undefined'
    },
    '== operator': {
      'null': 'null == null',
      'undefined': 'undefined == undefined',
      'null and undefined': 'null == undefined',
      'null and object': 'null == {}',
      'undefined and object': 'undefined == {}'
    },
    '!= operator': {
      'null': 'null != null',
      'undefined': 'undefined != undefined',
      'null and undefined': 'null != undefined',
      'null and object': 'null != {}',
      'undefined and object': 'undefined != {}'
    },
    'typeof': {
      'number': 'typeof 123',
      'string': 'typeof "asd"',
      'boolean': 'typeof true',
      'null': 'typeof null',
      'undefined': 'typeof undefined',
      'object': 'typeof ({})',
      'function': 'typeof (function () {})'
    },
    'if expressions': {
      'booleans cast to boolean': 'true ? 123 : 321',
      'numbers cast to boolean': '123 ? 456 : 789',
      'strings cast to boolean': '"" ? 456 : 789'
    },
    'function calls': {
      'one parameter': '(function () { return 123; })()',
      'two parameters': '(function (a) { return a; })(123)',
      'three parameters': '(function (a, b) { return a + b; })(123, 456)'
    },
    'objects': {
      'can lookup a member': '({ a: 123 }).a',
      'can call a member': '({\n	a: 123,\n	b: function () { return this.a }\n}).b()',
      'computed member expression': '({ asd: 123 })["a" + "sd"]',
      'can call a computed member': '({\n	asd: function () { return 123 }\n})["a" + "sd"]()',
      'can define a getter': '({\n	get a() { return 123 }\n}).a',
      'can define a setter': 'var s;\nvar a = {\n	get a() { return s },\n	set a(value) { s = value * 2 }\n};\na.a = 123;\na.a'
    },
    'assignment expressions': {
      'one assignment': 'var a;\na = 123;\na',
      'two assignments': 'var a, b;\na = 123;\nb = 456;\na + b',
      'assignment is an expression': 'var a, b;\na = b = 123;\na + b',
      'assignment to object member': 'var a;\na = {};\na.b = 123;\na.b',
      'assignment to computed object member': 'var a;\na = {};\na["a" + "sd"] = 123;\na.asd',
      'assignment from declaration': 'var a = 123, b = 456;\na + b',
      'assignment from var': 'var a = 123, b = a;\na + b'
    },
    '__proto__ and the prototype chain': {
      'lookup reached proto': 'var a = {};\na.__proto__ = { b: 123 };\na.b',
      'lookup does not reach proto': 'var a = { b: 456 };\na.__proto__ = { b: 123 };\na.b',
      'prototype chain': 'var a = {\n	__proto__: {\n		__proto__: {\n			b: 123\n		}\n	}\n};\na.b',
      'lookup on __proto__ directly': 'var a = {\n	__proto__: {\n		b: 123\n	}\n};\na.__proto__.b',
      'unresolved properties evaluate to undefined': 'var a = {};\na.b',
      'functions have a prototype': 'function A() {}\n!A.prototype'
    },
    'if statements': {
      'simple if statement': 'var a;\nif (true) {\n	a = 123;\n} else {\n	a = 321;\n}\na',
      'if statement without alternate': 'var a;\nif (false) {\n	a = 123;\n}\na',
      'return from if statement': '(function () {\n	if (true) {\n		return 123;\n	} else {\n		return 321;\n	}\n})()'
    },
    'sequence expressions': {
      'evaluate to the last term': '123, 321',
      'evaluates all terms': 'var a, b;\n(function () { a = 123; })(),(function () { b = 321; })();\na + b',
      'evaluates all terms, in order': 'var a = 0;\n(function () { a = a * 10 + 5; })(),\n(function () { a = a * 10 + 7; })();\na'
    },
    'new': {
      'instantiation and assignment to this': 'var A = function () { this.b = 123; };\nvar a = new A;\na.b',
      'set prototype': 'var A = function () { this.b = 123; };\nA.prototype = { c: 456 };\nvar a = new A;\na.b + a.c',
      'inheritance': 'var A = function () {};\nA.prototype = { c: 456 };\nvar B = function () {};\nB.prototype = new A;\nvar b = new B;\nb.c'
    },
    'function declarations': {
      'functions are bound to their name': 'function f() { return 123 }\nf()',
      'all functions are bound to their name before execution': 'function f() { return g() }\nfunction g() { return 123 }\nf()'
    },
    'function calls': {
      'more parameters than formal arguments': '(function (a, b) { return 123 })(1, 2, 3, 4)',
      'functions return undefined by default': '(function () {})()',
      'currying': '(function (a) {\n	return function (b) {\n		return a + b\n	}\n})(123)(456)'
    },
    'while': {
      'simple loop': 'var i = 10, sum = 0;\nwhile (i) {\n	sum = sum + i;\n	i = i - 1;\n}\nsum',
      'return from while': 'function f() {\n	while (true) {\n		return 123\n	}\n}\nf()',
      'return from nested while': 'function f() {\n	while (true) {\n		while (true) {\n			return 123\n		}\n	}\n}\nf()'
    },
    'for': {
      'simple for': 'var sum = 0;\nfor (var i = 10; i; i = i - 1) {\n	sum = sum + i;\n}\nsum',
      'return from for': 'function f() {\n	var sum = 0;\n	for (var i = 10; i; i = i - 1) {\n		return 123\n	}\n}\nf()'
    },
    'recursion': {
      'function declaration can refer to itself': 'function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n}\nsum(10)',
      'named function expression can refer to itself': '(function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n})(10)'
    },
    'scopes': {
      'undefined is located on window': 'undefined',
      'window is located on window': 'window === window.window',
      'local variables shadow top level variables': 'var a = 123;\n(function () {\n	var a = 321;\n	return a;\n})()',
      'local variables shadow parent scopes': '(function () {\n	var a = 123;\n	return (function () {\n		var a = 321;\n		return a;\n	})()\n})()',
      'local variables does not shadow function parameter': '(function (a) {\n	var a;\n	return a;\n})(123)',
      'the global context has a this': 'this'
    },
    'Object.create': {
      'can create an object with a prototype': 'var a = Object.create({ b: 123 });\na.b',
      'can access prototype via __proto__': 'var a = Object.create({ b: 123 });\na.__proto__.b'
    },
    'Object.keys': {
      'returns an empty array for an empty object': 'Object.keys({})',
      'returns the keys of an object': 'Object.keys({ a: 123, b: 321 })'
    },
    'Array': {
      'can construct': 'var a = [11, 22, 33];\na[1]',
      'can set/get numeric property': 'var a = [];\na[3] = 123;\na[3]'
    },
    'Array length': {
      'for empty arrays': '[].length',
      'for non-empty arrays': '[11, 22, 33].length',
      'for sparse arrays': 'var a = [];\na[3] = 123;\na.length'
    },
    'Array methods': {
      'toString': '[11, 22, 33, 44, 55].toString()',
      'slice': '[11, 22, 33, 44, 55].slice(2, 3)',
      'push return': '[11, 22, 33, 44, 55].push(66)',
      'push original array': 'var a = [11, 22, 33, 44, 55];\na.push(66);\na',
      'pop return': '[11, 22, 33, 44, 55].pop()',
      'pop original array': 'var a = [11, 22, 33, 44, 55];\na.pop();\na',
      'forEach iterates over an array': 'var s = 0;\n[11, 22].forEach(function (element) {\n	s = s + element;\n});\ns',
      'forEach indices': 'var s = 0;\n[11, 22].forEach(function (element, index) {\n	s = s + index;\n});\ns',
      'forEach array argument': 'var s = 0;\n[11, 22].forEach(function (element, index, array) {\n	s = s + array[index];\n});\ns',
      'forEach optional this': 'var s = 0;\n[11, 22].forEach(function (element, index, array) {\n	s = s + this;\n}, 123);\ns',
      'map iterates over an array': '[11, 22].map(function (element) {\n	return element * element;\n});',
      'filter eliminates some elements': '[11, 22, 33, 44].filter(function (element) {\n	return element === 22;\n});',
      'filter eliminates all elements when no return is present': '[11, 22, 33, 44].filter(function (element) {\n});',
      'filter preserves all elements': '[11, 22, 33, 44].filter(function (element) {\n	return true;\n});',
      'reduce can sum up numbers': '[11, 22, 33, 44].reduce(function (base, element) {\n	return base + element;\n});',
      'reduce can take an initial value': '[11, 22, 33, 44].reduce(function (base, element) {\n	return base + element;\n}, 123);',
      'reduce is called for all elements when the initial value is present': 'var calls = 0;\n[11, 22, 33, 44].reduce(function (base, element) {\n	calls = calls + 1;\n}, 123);\ncalls',
      'reduce skips the first element when the initial value is missing': 'var calls = 0;\n[11, 22, 33, 44].reduce(function (base, element) {\n	calls = calls + 1;\n});\ncalls'
    },
    'Map': {
      'constructor without arguments': 'var map = new Map;\nmap.get(123)',
      'constructor with arguments': 'var map = new Map([[123, \'asd\'], [321, \'dsa\']]);\nmap.get(123) + map.get(321)'
    },
    'Map methods': {
      'get returns undefined if the entry is missing': 'var map = new Map;\nmap.get(123) === undefined',
      'has returns true': 'var map = new Map;\nmap.has(123)',
      'has returns false': 'var map = new Map([[123, 321]]);\nmap.has(123)',
      'set can set things': 'var map = new Map;\nmap.set(123, "dsa")\nmap.get(123)',
      'set can re-set things': 'var map = new Map([[123, 321]]);\nmap.set(123, "asd")\nmap.get(123)',
      'forEach iterates over entries': 'var s = 0;\nvar map = new Map([["a", 123], ["b", 321]]);\nmap.forEach(function (value) {\n	s = s + value;\n});\ns',
      'forEach keys': 'var s = "";\nvar map = new Map([["a", 123], ["b", 321]]);\nmap.forEach(function (value, key) {\n	s = s + key;\n});\ns'
    },
    'Function methods': {
      'apply': 'var f = function (a, b) { return a + b };\nf.apply(null, [11, 22])',
      'apply with this': 'var f = function (a) { return this + a };\nf.apply(11, [22])',
      'call': 'var f = function (a, b) { return a + b };\nf.call(null, 11, 22)',
      'call with this': 'var f = function (a) { return this + a };\nf.call(11, 22)'
    }
  };

  if (window.snippets == null) {
    window.snippets = {};
  }

  Object.assign(window.snippets, snippets);

}).call(this);
