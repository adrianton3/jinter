// Generated by CoffeeScript 1.8.0
(function() {
  var snippets;

  snippets = {
    'literal': {
      'numbers': '1',
      'booleans': 'true',
      'strings': '"asd"'
    },
    '+ operator': {
      'numbers': '2 + 3',
      'strings': '"asd" + "dsa"',
      'number and string': '123 + "asd"',
      'string and number': '"asd" + 123'
    },
    'if expressions': {
      'booleans cast to boolean': 'true ? 123 : 321',
      'numbers cast to boolean': '123 ? 456 : 789',
      'strings cast to boolean': '"" ? 456 : 789'
    },
    'function calls': {
      'one parameter': '(function () { return 123; })()',
      'two parameters': '(function (a) { return a; })(123)',
      'three parameters': '(function (a, b) { return a + b; })(123, 456)'
    },
    'objects': {
      'can lookup a property': '({ a: 123 }).a',
      'can call a property': '({ a: 123, b: function () { return this.a } }).b()'
    },
    'assignment expressions': {
      'one assignment': 'var a;\na = 123;\na',
      'two assignments': 'var a, b;\na = 123;\nb = 456;\na + b',
      'assignment is an expression': 'var a, b;\na = b = 123;\na + b',
      'assignment to object member': 'var a;\na = {};\na.b = 123;\na.b',
      'assignment from declaration': 'var a = 123, b = 456;\na + b',
      'assignment from var': 'var a = 123, b = a;\na + b'
    },
    '__proto__ and the prototype chain': {
      'lookup reached proto': 'var a = {};\na.__proto__ = { b: 123 };\na.b',
      'lookup does not reach proto': 'var a = { b: 456 };\na.__proto__ = { b: 123 };\na.b',
      'prototype chain': 'var a = {\n	__proto__: {\n		__proto__: {\n			b: 123\n		}\n	}\n};\na.b',
      'lookup on __proto__ directly': 'var a = {\n	__proto__: {\n		b: 123\n	}\n};\na.__proto__.b'
    },
    'if statements': {
      'simple if statement': 'var a;\nif (true) {\n	a = 123;\n} else {\n	a = 321;\n}\na',
      'return from if statement': '(function () {\n	if (true) {\n		return 123;\n	} else {\n		return 321;\n	}\n})()'
    },
    'new': {
      'instantiation and assignment to this': 'var A = function () { this.b = 123; };\nvar a = new A;\na.b',
      'set prototype': 'var A = function () { this.b = 123; };\nA.prototype = { c: 456 };\nvar a = new A;\na.b + a.c',
      'inheritance': 'var A = function () {};\nA.prototype = { c: 456 };\nvar B = function () {};\nB.prototype = new A;\nvar b = new B;\nb.c'
    },
    'function declarations': {
      'functions are bound to their name': 'function f() { return 123 }\nf()',
      'all functions are bound to their name before execution': 'function f() { return g() }\nfunction g() { return 123 }\nf()'
    },
    'function calls': {
      'more parameters than formal arguments': '(function (a, b) { return 123 })(1, 2, 3, 4)',
      'functions return undefined by default': '(function () {})()',
      'currying': '(function (a) {\n	return function (b) {\n		return a + b\n	}\n})(123)(456)'
    },
    'while': {
      'simple loop': 'var i = 10, sum = 0;\nwhile (i) {\n	sum = sum + i;\n	i = i - 1;\n}\nsum',
      'return from while': 'function f() {\n	while (true) {\n		return 123\n	}\n}\nf()',
      'return from nested while': 'function f() {\n	while (true) {\n		while (true) {\n			return 123\n		}\n	}\n}\nf()'
    },
    'for': {
      'simple for': 'var sum = 0;\nfor (var i = 10; i; i = i - 1) {\n	sum = sum + i;\n}\nsum',
      'return from for': 'function f() {\n	var sum = 0;\n	for (var i = 10; i; i = i - 1) {\n		return 123\n	}\n}\nf()'
    },
    'recursion': {
      'function declaration can refer to itself': 'function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n}\nsum(10)',
      'named function expression can refer to itself': '(function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n})(10)'
    }
  };

  if (window.snippets == null) {
    window.snippets = {};
  }

  Object.assign(window.snippets, snippets);

}).call(this);
