// Generated by CoffeeScript 1.8.0
(function() {
  var snippets;

  snippets = {
    'literal': {
      'numbers': '1',
      'booleans': 'true',
      'strings': '"asd"'
    },
    'binary +': {
      'numbers': '2 + 3',
      'strings': '"asd" + "dsa"',
      'number and string': '123 + "asd"',
      'string and number': '"asd" + 123',
      'with toString': 'var a = { toString: function () { return "asd" } };\na + 123',
      'with valueOf': 'var a = { valueOf: function () { return 234 } };\na + 123',
      'valueOf has precedence over toString': 'var a = {\n	toString: function () { return "asd" },\n	valueOf: function () { return 234 }\n};\na + 123',
      'toString can return a number': 'var a = { toString: function () { return 234 } };\na + 123',
      'valueOf can return a string': 'var a = { valueOf: function () { return "asd" } };\na + 123'
    },
    'unary +': {
      'number': '+123',
      'numberic string': '+"123"',
      'non-numberic string': '+"asd"',
      'boolean': '+true',
      'null': '+null',
      'undefined': '+undefined',
      'object': '+({})'
    },
    'unary -': {
      'number': '-123',
      'numberic string': '-"123"',
      'non-numberic string': '-"asd"',
      'boolean': '-true',
      'null': '-null',
      'undefined': '-undefined',
      'object': '-({})'
    },
    '! operator': {
      'number': '!123',
      'string': '!"asd"',
      'boolean': '!true',
      'null': '!null',
      'undefined': '!undefined',
      'object': '!({})'
    },
    'binary -': {
      'numbers': '2 - 3',
      'strings': '"2" - "3"',
      'number and string': '123 + "234"',
      'string and number': '"234" + 123'
    },
    '* operator': {
      'numbers': '2 * 3',
      'strings': '"2" * "3"'
    },
    '&& operator': {
      'numbers': '2 && 3',
      'strings': '"asd" && ""',
      'booleans': 'false && true',
      'null': 'true && null',
      'undefined': 'true && undefined'
    },
    '|| operator': {
      'numbers': '2 || 3',
      'strings': '"asd" || ""',
      'booleans': 'false || true',
      'null': 'true || null',
      'undefined': 'true || undefined'
    },
    '=== operator': {
      'numbers': '1 + 4 === 2 + 3',
      'strings': '"a" + "sd" === "as" + "d"',
      'boolean': 'false === true',
      'different objects': '({}) === ({})',
      'same object': 'var a = {};\na === a',
      'null': 'null === null',
      'undefined': 'undefined === undefined'
    },
    '!== operator': {
      'numbers': '2 + 4 !== 2 + 3',
      'strings': '"as" !== "as" + "d"',
      'boolean': 'true !== true',
      'different objects': '({}) !== ({})',
      'same object': 'var a = {};\na !== a',
      'null': 'null !== null',
      'undefined': 'undefined !== undefined',
      'null and undefined': 'null !== undefined'
    },
    '== operator': {
      'null': 'null == null',
      'undefined': 'undefined == undefined',
      'null and undefined': 'null == undefined',
      'null and object': 'null == {}',
      'undefined and object': 'undefined == {}'
    },
    '!= operator': {
      'null': 'null != null',
      'undefined': 'undefined != undefined',
      'null and undefined': 'null != undefined',
      'null and object': 'null != {}',
      'undefined and object': 'undefined != {}'
    },
    'typeof': {
      'number': 'typeof 123',
      'string': 'typeof "asd"',
      'boolean': 'typeof true',
      'null': 'typeof null',
      'undefined': 'typeof undefined',
      'object': 'typeof ({})',
      'function': 'typeof (function () {})'
    },
    'if expressions': {
      'booleans cast to boolean': 'true ? 123 : 321',
      'numbers cast to boolean': '123 ? 456 : 789',
      'strings cast to boolean': '"" ? 456 : 789'
    },
    'function calls': {
      'one parameter': '(function () { return 123; })()',
      'two parameters': '(function (a) { return a; })(123)',
      'three parameters': '(function (a, b) { return a + b; })(123, 456)'
    },
    'objects': {
      'can lookup a member': '({ a: 123 }).a',
      'can lookup a member with a string key': '({ "a": 123 }).a',
      'can call a member': '({\n	a: 123,\n	b: function () { return this.a }\n}).b()',
      'computed member expression': '({ asd: 123 })["a" + "sd"]',
      'can call a computed member': '({\n	asd: function () { return 123 }\n})["a" + "sd"]()',
      'can define a getter': '({\n	get a() { return 123 }\n}).a',
      'can define a setter': 'var s;\nvar a = {\n	get a() { return s },\n	set a(value) { s = value * 2 }\n};\na.a = 123;\na.a'
    },
    'assignment expressions': {
      'one assignment': 'var a;\na = 123;\na',
      'two assignments': 'var a, b;\na = 123;\nb = 456;\na + b',
      'assignment is an expression': 'var a, b;\na = b = 123;\na + b',
      'assignment to object member': 'var a;\na = {};\na.b = 123;\na.b',
      'assignment to computed object member': 'var a;\na = {};\na["a" + "sd"] = 123;\na.asd',
      'assignment from declaration': 'var a = 123, b = 456;\na + b',
      'assignment from var': 'var a = 123, b = a;\na + b'
    },
    '__proto__ and the prototype chain': {
      'lookup reached proto': 'var a = {};\na.__proto__ = { b: 123 };\na.b',
      'lookup does not reach proto': 'var a = { b: 456 };\na.__proto__ = { b: 123 };\na.b',
      'prototype chain': 'var a = {\n	__proto__: {\n		__proto__: {\n			b: 123\n		}\n	}\n};\na.b',
      'lookup on __proto__ directly': 'var a = {\n	__proto__: {\n		b: 123\n	}\n};\na.__proto__.b',
      'unresolved properties evaluate to undefined': 'var a = {};\na.b',
      'functions have a prototype': 'function A() {}\n!A.prototype'
    },
    'if statements': {
      'simple if statement': 'var a;\nif (true) {\n	a = 123;\n} else {\n	a = 321;\n}\na',
      'if statement without alternate': 'var a;\nif (false) {\n	a = 123;\n}\na',
      'return from if statement': '(function () {\n	if (true) {\n		return 123;\n	} else {\n		return 321;\n	}\n})()'
    },
    'sequence expressions': {
      'evaluate to the last term': '123, 321',
      'evaluates all terms': 'var a, b;\n(function () { a = 123; })(),(function () { b = 321; })();\na + b',
      'evaluates all terms, in order': 'var a = 0;\n(function () { a = a * 10 + 5; })(),\n(function () { a = a * 10 + 7; })();\na'
    },
    'new': {
      'instantiation and assignment to this': 'var A = function () { this.b = 123; };\nvar a = new A;\na.b',
      'set prototype': 'var A = function () { this.b = 123; };\nA.prototype = { c: 456 };\nvar a = new A;\na.b + a.c',
      'inheritance': 'var A = function () {};\nA.prototype = { c: 456 };\nvar B = function () {};\nB.prototype = new A;\nvar b = new B;\nb.c'
    },
    'function declarations': {
      'functions are bound to their name': 'function f() { return 123 }\nf()',
      'all functions are bound to their name before execution': 'function f() { return g() }\nfunction g() { return 123 }\nf()'
    },
    'function calls': {
      'more parameters than formal arguments': '(function (a, b) { return b })(11, 22, 33, 44)',
      'less parameters than formal arguments': '(function (a, b) { return b })(321)',
      'functions return undefined by default': '(function () {})()',
      'currying': '(function (a) {\n	return function (b) {\n		return a + b\n	}\n})(123)(456)'
    },
    'the arguments object': {
      'is available in a function': '(function () {\n	return arguments[0];\n})(123);',
      'works outside of the function': '(function () {\n	return arguments;\n})(123, 765)[1];',
      'can be forwarded to apply': 'function f(a, b) {\n	return a + b;\n}\nfunction g() {\n	return f.apply(null, arguments);\n}\ng(123, 321);'
    },
    'while': {
      'simple loop': 'var i = 10, sum = 0;\nwhile (i) {\n	sum = sum + i;\n	i = i - 1;\n}\nsum',
      'return from while': 'function f() {\n	while (true) {\n		return 123\n	}\n}\nf()',
      'return from nested while': 'function f() {\n	while (true) {\n		while (true) {\n			return 123\n		}\n	}\n}\nf()'
    },
    'for': {
      'simple for': 'var sum = 0;\nfor (var i = 10; i; i = i - 1) {\n	sum = sum + i;\n}\nsum',
      'return from for': 'function f() {\n	var sum = 0;\n	for (var i = 10; i; i = i - 1) {\n		return 123\n	}\n}\nf()'
    },
    'recursion': {
      'function declaration can refer to itself': 'function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n}\nsum(10)',
      'named function expression can refer to itself': '(function sum(n) {\n	if (n) {\n		return n + sum(n - 1)\n	} else {\n		return 0\n	}\n})(10)'
    },
    'scopes': {
      'undefined is located on window': 'undefined',
      'window is located on window': 'window === window.window',
      'local variables shadow top level variables': 'var a = 123;\n(function () {\n	var a = 321;\n	return a;\n})()',
      'local variables shadow parent scopes': '(function () {\n	var a = 123;\n	return (function () {\n		var a = 321;\n		return a;\n	})()\n})()',
      'local variables does not shadow function parameter': '(function (a) {\n	var a;\n	return a;\n})(123)',
      'the global context has a this': 'this'
    }
  };

  if (window.snippets == null) {
    window.snippets = {};
  }

  Object.assign(window.snippets, snippets);

}).call(this);
