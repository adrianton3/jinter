// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var ARRAY, BOOLEAN, FUNCTION, NULL, NUMBER, Nodes, OBJECT, STRING, UNDEFINED, call, callNew, callRaw, computeMemberKey, ev;

  NUMBER = jinter.NUMBER, BOOLEAN = jinter.BOOLEAN, STRING = jinter.STRING, NULL = jinter.NULL, UNDEFINED = jinter.UNDEFINED, FUNCTION = jinter.FUNCTION, OBJECT = jinter.OBJECT, ARRAY = jinter.ARRAY;

  ev = function(exp, env) {
    if (env == null) {
      throw new Error('null env');
    }
    return Nodes[exp.type](exp, env);
  };

  Nodes = {};

  Nodes['Literal'] = function(exp, env) {
    var dataType, value;
    value = exp.value, dataType = exp.dataType;
    if (dataType === 'number') {
      return new NUMBER(value);
    } else if (dataType === 'boolean') {
      return new BOOLEAN(value);
    } else if (dataType === 'string') {
      return new STRING(value);
    } else if (dataType === 'object') {
      return NULL;
    }
  };

  Nodes['Identifier'] = function(exp, env) {
    return env.get(exp.name);
  };

  (function() {
    var OPERATORS;
    OPERATORS = {
      '+': function(operand) {
        return new NUMBER(operand.asNumber());
      },
      '-': function(operand) {
        return new NUMBER(-operand.asNumber());
      },
      '!': function(operand) {
        return new BOOLEAN(!operand.asBoolean());
      },
      'typeof': function(operand) {
        return new STRING(operand.typeOf);
      },
      'void': function(operand) {
        return UNDEFINED;
      }
    };
    return Nodes['UnaryExpression'] = function(exp, env) {
      var operand;
      operand = ev(exp.argument, env);
      return OPERATORS[exp.operator](operand);
    };
  })();

  (function() {
    var OPERATORS, eqeq, eqeqeq;
    eqeqeq = function(left, right) {
      var _ref;
      if (left.type !== right.type) {
        return false;
      } else if ((_ref = left.type) === 'number' || _ref === 'boolean' || _ref === 'string') {
        return left.value === right.value;
      } else if (left.type === 'object') {
        return left === right;
      } else {
        return true;
      }
    };
    eqeq = function(left, right) {
      if ((left === NULL || left === UNDEFINED) && (right === NULL || right === UNDEFINED)) {
        return true;
      } else {
        return eqeqeq(left, right);
      }
    };
    OPERATORS = {
      '+': function(left, right) {
        var leftPrimitive, rightPrimitive;
        leftPrimitive = left.asPrimitive();
        rightPrimitive = right.asPrimitive();
        if (leftPrimitive.type === 'string' || rightPrimitive.type === 'string') {
          return new STRING(leftPrimitive.asString() + rightPrimitive.asString());
        } else {
          return new NUMBER(leftPrimitive.asNumber() + rightPrimitive.asNumber());
        }
      },
      '-': function(left, right) {
        return new NUMBER(left.asNumber() - right.asNumber());
      },
      '*': function(left, right) {
        return new NUMBER(left.asNumber() * right.asNumber());
      },
      '===': function(left, right) {
        return new BOOLEAN(eqeqeq(left, right));
      },
      '!==': function(left, right) {
        return new BOOLEAN(!eqeqeq(left, right));
      },
      '==': function(left, right) {
        return new BOOLEAN(eqeq(left, right));
      },
      '!=': function(left, right) {
        return new BOOLEAN(!eqeq(left, right));
      },
      '<': function(left, right) {
        var leftPrimitive, rightPrimitive;
        leftPrimitive = left.type === 'object' ? left.asPrimitive() : left;
        rightPrimitive = right.type === 'object' ? right.asPrimitive() : right;
        if (leftPrimitive.type === 'string' && rightPrimitive.type === 'string') {
          return new BOOLEAN(leftPrimitive.value < rightPrimitive.value);
        } else {
          return new BOOLEAN(leftPrimitive.asNumber() < rightPrimitive.asNumber());
        }
      },
      '<=': function(left, right) {
        var leftPrimitive, rightPrimitive;
        leftPrimitive = left.type === 'object' ? left.asPrimitive() : left;
        rightPrimitive = right.type === 'object' ? right.asPrimitive() : right;
        if (leftPrimitive.type === 'string' && rightPrimitive.type === 'string') {
          return new BOOLEAN(leftPrimitive.value <= rightPrimitive.value);
        } else {
          return new BOOLEAN(leftPrimitive.asNumber() <= rightPrimitive.asNumber());
        }
      }
    };
    return Nodes['BinaryExpression'] = function(exp, env) {
      var left, right;
      left = ev(exp.left, env);
      right = ev(exp.right, env);
      return OPERATORS[exp.operator](left, right);
    };
  })();

  Nodes['LogicalExpression'] = function(exp, env) {
    var left, leftBoolean;
    left = ev(exp.left, env);
    leftBoolean = left.asBoolean();
    if (exp.operator === '&&') {
      if (!leftBoolean) {
        return left;
      }
    } else {
      if (leftBoolean) {
        return left;
      }
    }
    return ev(exp.right, env);
  };

  Nodes['ConditionalExpression'] = function(exp, env) {
    var testResult;
    testResult = ev(exp.test, env);
    if (testResult.asBoolean()) {
      return ev(exp.consequent, env);
    } else {
      return ev(exp.alternate, env);
    }
  };

  Nodes['IfStatement'] = function(exp, env) {
    var testResult;
    testResult = ev(exp.test, env);
    if (testResult.asBoolean()) {
      return ev(exp.consequent, env);
    } else if (exp.alternate != null) {
      return ev(exp.alternate, env);
    }
  };

  Nodes['WhileStatement'] = function(exp, env) {
    var returnCandidate;
    while ((ev(exp.test, env)).asBoolean()) {
      returnCandidate = ev(exp.body, env);
      if (returnCandidate != null ? returnCandidate["return"] : void 0) {
        return returnCandidate;
      }
    }
  };

  Nodes['ForStatement'] = function(exp, env) {
    var returnCandidate;
    ev(exp.init, env);
    while ((ev(exp.test, env)).asBoolean()) {
      returnCandidate = ev(exp.body, env);
      if (returnCandidate != null ? returnCandidate["return"] : void 0) {
        return returnCandidate;
      }
      ev(exp.update, env);
    }
  };

  Nodes['VariableDeclaration'] = function(exp, env) {
    exp.declarations.forEach(function(declaration) {
      var name, value;
      if (declaration.init == null) {
        return;
      }
      name = declaration.id.name;
      value = ev(declaration.init, env);
      env.set(name, value);
    });
  };

  computeMemberKey = function(exp, env) {
    var key;
    if (exp.computed) {
      key = ev(exp.property, env);
      return key.asString();
    } else {
      return exp.property.name;
    }
  };

  Nodes['AssignmentExpression'] = function(exp, env) {
    var entry, key, name, object, value;
    if (exp.left.type === 'MemberExpression') {
      object = ev(exp.left.object, env);
      key = computeMemberKey(exp.left, env);
      value = ev(exp.right, env);
      entry = object.get(key);
      if ((entry != null ? entry.descriptor : void 0) != null) {
        if (entry.set != null) {
          call(entry.set, object, [value]);
        }
      } else {
        object.put(key, value);
      }
    } else {
      name = exp.left.name;
      value = ev(exp.right, env);
      env.set(name, value);
    }
    return value;
  };

  Nodes['UpdateExpression'] = function(exp, env) {
    var entry, key, name, object, oldValue, value;
    if (exp.operator !== '++' || exp.prefix) {
      throw new Error("update operator " + exp.operator + " not implemented");
    }
    if (exp.argument.type === 'MemberExpression') {
      object = ev(exp.argument.object, env);
      key = computeMemberKey(exp.argument, env);
      entry = object.get(key);
      oldValue = (entry != null ? entry.descriptor : void 0) != null ? entry.get != null ? call(entry.get, object, []) : UNDEFINED : entry;
      value = new NUMBER(oldValue.asNumber() + 1);
      if ((entry != null ? entry.descriptor : void 0) != null) {
        if (entry.set != null) {
          call(entry.set, object, [value]);
        }
      } else {
        object.put(key, value);
      }
    } else {
      name = exp.argument.name;
      oldValue = ev(exp.argument, env);
      value = new NUMBER(oldValue.asNumber() + 1);
      env.set(name, value);
    }
    return oldValue;
  };

  Nodes['SequenceExpression'] = function(exp, env) {
    return exp.expressions.reduce(function(prev, expression) {
      return ev(expression, env);
    }, null);
  };

  Nodes['BlockStatement'] = function(exp, env) {
    var returnCandidate, statement, _i, _len, _ref;
    _ref = exp.body;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      statement = _ref[_i];
      returnCandidate = ev(statement, env);
      if (returnCandidate != null ? returnCandidate["return"] : void 0) {
        return returnCandidate;
      }
    }
  };

  Nodes['ReturnStatement'] = function(exp, env) {
    var value;
    value = exp.argument != null ? ev(exp.argument, env) : UNDEFINED;
    return {
      "return": true,
      value: value
    };
  };

  Nodes['ThisExpression'] = function(exp, env) {
    return env.get('this');
  };

  Nodes['ArrayExpression'] = function(exp, env) {
    var array;
    array = new ARRAY;
    exp.elements.forEach(function(element, index) {
      var value;
      value = ev(element, env);
      return array.put(index, value);
    });
    return array;
  };

  Nodes['ObjectExpression'] = function(exp, env) {
    var object;
    object = new OBJECT(jinter.OBJECT_PROTOTYPE);
    exp.properties.forEach(function(_arg) {
      var key, kind, name, value;
      key = _arg.key, value = _arg.value, kind = _arg.kind;
      name = key.type === "Identifier" ? key.name : key.value;
      value = ev(value, env);
      if (kind === 'get') {
        return object.defineGet(name, value);
      } else if (kind === 'set') {
        return object.defineSet(name, value);
      } else {
        return object.put(name, value);
      }
    });
    return object;
  };

  Nodes['MemberExpression'] = function(exp, env) {
    var entry, key, object;
    object = ev(exp.object, env);
    key = computeMemberKey(exp, env);
    entry = object.get(key);
    if (entry == null) {
      return UNDEFINED;
    } else if (entry.descriptor != null) {
      if (entry.get != null) {
        return call(entry.get, object, []);
      } else {
        return UNDEFINED;
      }
    } else {
      return entry;
    }
  };

  callRaw = function(closure, thisArgument, args) {
    var newEnv;
    if (closure["native"]) {
      return closure.fun.apply(thisArgument, args);
    }
    newEnv = closure.env.addEntry();
    if (closure.ownName != null) {
      newEnv.addBinding(closure.ownName.name, closure);
    }
    newEnv.addBinding('this', thisArgument);
    newEnv.addBinding('arguments', new ARRAY(args));
    closure.formalArguments.forEach(function(formalArgument, index) {
      var value;
      value = index < args.length ? args[index] : UNDEFINED;
      newEnv.addBinding(formalArgument, value);
    });
    closure.body.vars.forEach(function(name) {
      if (!newEnv.entryHas(name)) {
        newEnv.addBinding(name, UNDEFINED);
      }
    });
    closure.body.functionDeclarations.forEach(function(node) {
      var name;
      name = node.id.name;
      closure = ev(node, newEnv);
      newEnv.addBinding(name, closure);
    });
    return ev(closure.body, newEnv);
  };

  call = function(closure, thisArgument, args) {
    var returnCandidate;
    returnCandidate = callRaw(closure, thisArgument, args);
    if (returnCandidate != null ? returnCandidate["return"] : void 0) {
      return returnCandidate.value;
    } else {
      return UNDEFINED;
    }
  };

  callNew = function(closure, thisArgument, args, env) {
    var returnCandidate;
    returnCandidate = callRaw(closure, thisArgument, args);
    if ((returnCandidate != null ? returnCandidate["return"] : void 0) && returnCandidate.value.type === 'object') {
      return returnCandidate.value;
    } else {
      return thisArgument;
    }
  };

  Nodes['CallExpression'] = function(exp, env) {
    var args, closure, key, thisArgument;
    if (exp.callee.type === 'MemberExpression') {
      thisArgument = ev(exp.callee.object, env);
      key = computeMemberKey(exp.callee, env);
      closure = thisArgument.get(key);
    } else {
      thisArgument = NULL;
      closure = ev(exp.callee, env);
    }
    args = exp["arguments"].map(function(argument) {
      return ev(argument, env);
    });
    return call(closure, thisArgument, args);
  };

  Nodes['NewExpression'] = function(exp, env) {
    var args, closure, thisArgument;
    closure = ev(exp.callee, env);
    thisArgument = closure["native"] ? null : new OBJECT(closure.get('prototype'));
    args = exp["arguments"].map(function(argument) {
      return ev(argument, env);
    });
    return callNew(closure, thisArgument, args);
  };

  Nodes['FunctionDeclaration'] = function(exp, env) {
    var formalArguments;
    formalArguments = exp.params.map(function(formalArgument) {
      return formalArgument.name;
    });
    return new FUNCTION(exp.body, env, formalArguments);
  };

  Nodes['FunctionExpression'] = function(exp, env) {
    var formalArguments;
    formalArguments = exp.params.map(function(formalArgument) {
      return formalArgument.name;
    });
    return new FUNCTION(exp.body, env, formalArguments, exp.id);
  };

  Nodes['Program'] = function(exp, env) {
    var newEnv;
    newEnv = env.addEntry();
    newEnv.addBinding('this', UNDEFINED);
    exp.vars.forEach(function(name) {
      newEnv.addBinding(name, UNDEFINED);
    });
    exp.functionDeclarations.forEach(function(node) {
      var closure, name;
      name = node.id.name;
      closure = ev(node, newEnv);
      newEnv.addBinding(name, closure);
    });
    return exp.body.reduce(function(prev, statement) {
      return ev(statement, newEnv);
    }, null);
  };

  Nodes['ExpressionStatement'] = function(exp, env) {
    return ev(exp.expression, env);
  };

  if (window.jinter == null) {
    window.jinter = {};
  }

  window.jinter.ev = ev;

  window.jinter.callRaw = callRaw;

  window.jinter.call = call;

}).call(this);
